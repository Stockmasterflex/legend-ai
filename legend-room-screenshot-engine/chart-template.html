<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Legend Room Chart</title>
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <style>
        /* Basic styling to make the chart fill the page */
        html, body, #container {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #131722; /* Match TradingView dark theme background */
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script type="text/javascript">
        // Function to get query parameters from the page's URL
        const urlParams = new URLSearchParams(window.location.search);
        
        // Get the 'symbol' parameter, defaulting to 'SPY' if it's not provided.
        // This allows the caller to specify which stock to chart.
const symbol = urlParams.get('symbol') || 'SPY';
        const pivot = parseFloat(urlParams.get('pivot') || 'NaN');
        const entryParam = parseFloat(urlParams.get('entry') || 'NaN');
        const stopParam = parseFloat(urlParams.get('stop') || 'NaN');
        const targetParam = parseFloat(urlParams.get('target') || 'NaN');
        const pattern = urlParams.get('pattern') || '';

        new TradingView.widget({
            autosize: true,
            symbol: symbol,
            interval: "D",
            timezone: "Etc/UTC",
            theme: "dark",
            style: "1",
            locale: "en",
            container_id: "container",
            // Remove the default top toolbar to get a cleaner chart image
            toolbar_bg: "#f1f3f6",
            enable_publishing: false,
            hide_top_toolbar: true,
            save_image: false,
            container_id: "container",
            studies: [
                "Volume@tv-basicstudies",
                "RSI@tv-basicstudies"
            ],
        });

        // Draw simple overlays using HTML canvas on top of TradingView container (best-effort)
        const container = document.getElementById('container');
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.inset = '0';
        overlay.style.pointerEvents = 'none';
        container.appendChild(overlay);
        const canvas = document.createElement('canvas');
        function resize(){ canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
        resize();
        window.addEventListener('resize', resize);
        overlay.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        const overlayData = window.__LEGEND_OVERLAYS || {};
        const priceLevels = overlayData.priceLevels || {};
        const overlayLines = Array.isArray(overlayData.lines) ? overlayData.lines : [];
        const overlayBoxes = Array.isArray(overlayData.boxes) ? overlayData.boxes : [];
        const overlayLabels = Array.isArray(overlayData.labels) ? overlayData.labels : [];
        const overlayArrows = Array.isArray(overlayData.arrows) ? overlayData.arrows : [];
        const overlayZones = Array.isArray(overlayData.zones) ? overlayData.zones : [];

        const entry = Number.isFinite(entryParam) ? entryParam : priceLevels.entry;
        const stop = Number.isFinite(stopParam) ? stopParam : priceLevels.stop;
        const targets = Array.isArray(priceLevels.targets) && priceLevels.targets.length
          ? priceLevels.targets
          : (Number.isFinite(targetParam) ? [targetParam] : []);

        const priceValues = [];
        [pivot, entry, stop].forEach((val) => { if (Number.isFinite(val)) priceValues.push(val); });
        targets.forEach((val) => { if (Number.isFinite(val)) priceValues.push(val); });
        overlayLines.forEach((line) => {
          if (Number.isFinite(line.y1)) priceValues.push(Number(line.y1));
          if (Number.isFinite(line.y2)) priceValues.push(Number(line.y2));
        });
        overlayBoxes.forEach((box) => {
          if (Number.isFinite(box.y1)) priceValues.push(Number(box.y1));
          if (Number.isFinite(box.y2)) priceValues.push(Number(box.y2));
        });
        overlayLabels.forEach((label) => {
          if (Number.isFinite(label.y)) priceValues.push(Number(label.y));
        });
        let minPrice = priceValues.length ? Math.min(...priceValues) : 1;
        let maxPrice = priceValues.length ? Math.max(...priceValues) : minPrice + 1;
        if (minPrice === maxPrice) {
          minPrice -= 1;
          maxPrice += 1;
        }

        const timestampValues = [];
        const toTimestamp = (value) => {
          const ts = Date.parse(value);
          return Number.isFinite(ts) ? ts : NaN;
        };
        overlayLines.forEach((line) => {
          const t1 = toTimestamp(line.x1);
          const t2 = toTimestamp(line.x2);
          if (Number.isFinite(t1)) timestampValues.push(t1);
          if (Number.isFinite(t2)) timestampValues.push(t2);
        });
        overlayBoxes.forEach((box) => {
          const t1 = toTimestamp(box.x1);
          const t2 = toTimestamp(box.x2);
          if (Number.isFinite(t1)) timestampValues.push(t1);
          if (Number.isFinite(t2)) timestampValues.push(t2);
        });
        overlayLabels.forEach((label) => {
          const t = toTimestamp(label.x);
          if (Number.isFinite(t)) timestampValues.push(t);
        });
        let minTs = timestampValues.length ? Math.min(...timestampValues) : 0;
        let maxTs = timestampValues.length ? Math.max(...timestampValues) : 1;
        if (minTs === maxTs) {
          minTs -= 43200000; // +/- 12h to avoid divide-by-zero
          maxTs += 43200000;
        }

        const priceToY = (price) => {
          const pct = (price - minPrice) / (maxPrice - minPrice);
          const clamped = Math.min(0.95, Math.max(0.05, pct));
          const top = canvas.height * 0.1;
          const bottom = canvas.height * 0.9;
          return bottom - (bottom - top) * clamped;
        };

        const timeToX = (value, fallbackIndex, total) => {
          const ts = toTimestamp(value);
          if (Number.isFinite(ts)) {
            const pct = (ts - minTs) / (maxTs - minTs);
            return 20 + (canvas.width - 40) * Math.min(0.98, Math.max(0.02, pct));
          }
          const denom = Math.max(total - 1, 1);
          return 20 + (canvas.width - 40) * (fallbackIndex / denom);
        };

        const drawPriceLevels = () => {
          ctx.font = '12px sans-serif';
          if (Number.isFinite(pivot)) {
            const y = priceToY(pivot);
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(20, y); ctx.lineTo(canvas.width - 20, y); ctx.stroke();
            ctx.fillStyle = '#ffcc00';
            ctx.fillText(`Pivot ${pivot.toFixed(2)}`, 24, y - 6);
          }
          if (Number.isFinite(entry)) {
            const y = priceToY(entry);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(20, y); ctx.lineTo(canvas.width - 20, y); ctx.stroke();
            ctx.fillStyle = '#00ff88';
            ctx.fillText(`Entry ${entry.toFixed(2)}`, 24, y - 6);
          }
          if (Number.isFinite(stop)) {
            const y = priceToY(stop);
            ctx.strokeStyle = '#ff5577';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(20, y); ctx.lineTo(canvas.width - 20, y); ctx.stroke();
            ctx.fillStyle = '#ff5577';
            ctx.fillText(`Stop ${stop.toFixed(2)}`, 24, y - 6);
          }
          targets.slice(0, 3).forEach((level, idx) => {
            if (!Number.isFinite(level)) return;
            const y = priceToY(level);
            ctx.strokeStyle = '#00d1ff';
            ctx.setLineDash([idx % 2 === 0 ? 6 : 3, 6]);
            ctx.beginPath(); ctx.moveTo(20, y); ctx.lineTo(canvas.width - 20, y); ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#00d1ff';
            ctx.fillText(`Target ${idx + 1} ${Number(level).toFixed(2)}`, canvas.width - 180, y - 6);
          });
          if (pattern) {
            ctx.fillStyle = '#9be7ff';
            ctx.fillText(`Pattern: ${pattern}`, canvas.width - 200, 26);
          }
        };

        const drawOverlayLines = () => {
          overlayLines.forEach((line, idx) => {
            if (!Number.isFinite(line.y1) || !Number.isFinite(line.y2)) return;
            const x1 = timeToX(line.x1, idx, overlayLines.length);
            const x2 = timeToX(line.x2, idx + 1, overlayLines.length + 1);
            const y1 = priceToY(Number(line.y1));
            const y2 = priceToY(Number(line.y2));
            ctx.strokeStyle = line.color || '#9be7ff';
            ctx.lineWidth = Number(line.width) || 1.5;
            if (line.dash) ctx.setLineDash([6, 6]);
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            if (line.dash) ctx.setLineDash([]);
          });
        };

        const drawOverlayZones = () => {
          overlayZones.forEach((zone, idx) => {
            if (!Number.isFinite(zone.y1) || !Number.isFinite(zone.y2)) return;
            const x1 = timeToX(zone.x1, idx, overlayZones.length);
            const x2 = timeToX(zone.x2, idx + 1, overlayZones.length + 1);
            const y1 = priceToY(Number(zone.y1));
            const y2 = priceToY(Number(zone.y2));
            const color = zone.color || '#3949ab';
            const opacity = typeof zone.opacity === 'number' ? Math.min(0.4, Math.max(0.05, zone.opacity)) : 0.12;
            const gradient = ctx.createLinearGradient(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2));
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, zone.toColor || color);
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = gradient;
            ctx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
            ctx.restore();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
          });
        };

        const drawOverlayBoxes = () => {
          overlayBoxes.forEach((box, idx) => {
            if (!Number.isFinite(box.y1) || !Number.isFinite(box.y2)) return;
            const x1 = timeToX(box.x1, idx, overlayBoxes.length);
            const x2 = timeToX(box.x2, idx + 1, overlayBoxes.length + 1);
            const y1 = priceToY(Number(box.y1));
            const y2 = priceToY(Number(box.y2));
            const opacity = typeof box.opacity === 'number' ? Math.min(0.6, Math.max(0.05, box.opacity)) : 0.15;
            ctx.save();
            ctx.fillStyle = box.color || '#1e88e5';
            ctx.globalAlpha = opacity;
            ctx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
            ctx.restore();
            ctx.strokeStyle = box.color || '#1e88e5';
            ctx.lineWidth = 1;
            ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
          });
        };

        const drawOverlayArrows = () => {
          overlayArrows.forEach((arrow, idx) => {
            if (!Number.isFinite(arrow.y1) || !Number.isFinite(arrow.y2)) return;
            const x1 = timeToX(arrow.x1, idx, overlayArrows.length);
            const x2 = timeToX(arrow.x2, idx + 1, overlayArrows.length + 1);
            const y1 = priceToY(Number(arrow.y1));
            const y2 = priceToY(Number(arrow.y2));
            ctx.strokeStyle = arrow.color || '#ffb74d';
            ctx.fillStyle = ctx.strokeStyle;
            ctx.lineWidth = Number(arrow.width) || 2;
            if (arrow.dash) ctx.setLineDash([6, 6]);
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.setLineDash([]);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const size = Number(arrow.size) || 10;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
          });
        };

        const drawOverlayLabels = () => {
          ctx.font = '12px sans-serif';
          overlayLabels.forEach((label, idx) => {
            if (!label || typeof label.text !== 'string') return;
            const x = timeToX(label.x, idx, overlayLabels.length + 1);
            const y = Number.isFinite(label.y) ? priceToY(Number(label.y)) : 40 + idx * 16;
            ctx.fillStyle = label.color || '#ffffff';
            ctx.fillText(label.text, x, y);
          });
        };

        const render = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawPriceLevels();
          drawOverlayZones();
          drawOverlayBoxes();
          drawOverlayLines();
          drawOverlayArrows();
          drawOverlayLabels();
        };

        setTimeout(render, 2200);
    </script>
</body>
</html>
